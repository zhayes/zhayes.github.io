<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[概率中加法和乘法原理以及排列和组合的定义]]></title>
    <url>%2F2019%2F08%2F23%2FpermutationAndCombination%2F</url>
    <content type="text"><![CDATA[转载自：伤神的博客——概率学系列 二：深入浅出 - 加法和乘法原理以及排列和组合的定义 加法原理如果某件事可以由$k$类不同途径之一去完成，在第一类途径中有$m1$种完成方法，在第二类途径中有$m2$，第$k$类途径中有$mk$种完成的方法，那么完成这件事总共有 $m1+m2+…+mk$种方法。 以上便是加法原理的定义，那么该如何解读呢？注意两点， 途径指的是完成一件事情的某一条完整途径；比如从$A$点到$Z$点由多条途径（注意，加法原理需要保证途径是单向的），但是只要是有这么一条途径完成了$A$$\rightarrow$$Z$，就称为一类途径； k 类不同路径这里的类可以更为直观的理解成条，既是 k 条路径；所以加法原理便是这些所有可能的途径之和。 乘法原理如果某件事需经过$k$个步骤才能完成，做第一步有$m1$种方法，做第二件事有$m2$种方法，…，做第 $k$ 步有 $mk$ 种方法，那么完成这件事总共有 $m1×m2×…×mk$ 种方法。 以上便是乘法原理的定义，那么又该如何解读呢？首先，与加法原理不同的是，加法原理实际上是站在结果的角度来思考问题的；而乘法原理是站在中间步骤的角度上来思考问题的；比如有多少个从 A 点到 Z 点的途径？加法原理是站在最终的结果的角度既途径来思考问题的，而乘法原理则是站在中间的步骤的可能性既方法的角度来思考问题的。其次，加法原理和乘法原理其实是相容的，比如，针对同一件事 $A$$\rightarrow$$Z$ 有多少条途径，该途径之和 $= m1×m2×…×mk$ 种方法。 由此，可以猜测，乘法原理感觉上是对加法原理的进行了一次抽象而已；针对同一件事，两种原理的计算结果相同，只是算法和研究问题的角度不同而已；那么笔者在这里所描述的这种抽象指的是什么？笔者试图通过下面的例子一步一步的进行推导； 考虑这样一种最简单的情况，假设我们有这样一个篮子，里面放置了编号分别为 $1、2、3$ 的三个小球，要完成这么一件事情，随机抽取两次，每次只取一个小球且不放回，试问，取出的两个小球的编号总共有多少种可能？(从概率学的观点，完成这件事总共的样本点是多少？) 从加法原理出发，我们知道，它研究问题的角度是事情的结果，所以笔者将所有可能的结果绘制了出来，如下图所示， 注意，笔者将该结果归为了三类，既是选中 $1$ 的途径、选中 $2$ 的途径和选中 $3$ 的途径，图中黑色表示两次选出的小球，就是一类途径既结果，标识 $A、B$ 分别表示第一次和第二次取球的动作；将这三类相关的所有途径的相加的总和 $6$，也就是通过加法原理所求得的所有可能性的总和，也就是概率学中所描述的总体样本点。上述关系同样可以简化成下面这张图，红色的线条表示选中 $1$ 号球的所有可能性，黑色线条表示选中 $2$ 号球的所有可能性，绿色线条表示选中 $3$ 号球的所有可能性； 那么，为什么笔者说乘法原理是对加法原理的抽象呢？其实乘法原理是对种种结果既途径进行了归纳和抽象，发现途径中的各个步骤与最终的结果（既所有途径之和）有着某种必然的关系，而通过数学的定义，可以归纳出这种关系；那么乘法原理是如何来从它的角度来描述这种关系的呢？注意，它研究问题的角度是从途径中的每一个步骤出发的，既是分别站在步骤 $A、B$ 的角度出发的，如上图可知，步骤 $A$ 有 $3$ 种选择，而步骤 $B$ 有 $2$ 种选择，那么每个步骤的选择是否与最终结果既所有途径之和存在某种必然的联系呢？步骤 $A$ 有 $3$ 种选择，如果选定任意一种选择以后，步骤 $B$ 都会有 2 种选择；所以这种关系可以用下面这个加法表达式来表示，$2+2+2$。 第一个 $2$ 表示选中 $1$ 号球以后的所有可能性，第二个 $2$ 表示选中 $2$ 号球以后的所有可能性，第三个 $2$ 表示选中 $3$ 号球以后的所有可能性；因此，我们得到了所有途径之和等于 $3$ 个 $2$ 相加这样的一个结果；实际上，这正是加法原理的解题思路，从某一个起点开始，计算所有可能的途径，然后将所有起点对应的途径的可能相加记得到最终的结果；然而，当我们将研究问题的角度转向过程中的每一个步骤以后，就会得到这样一个非常关键的结论，既所有途径之和 $= 3 个 2$ 相加；而这个结论就是将加法原理转向乘法原理的关键之所在了，数学家们顺势而为，将这种关系定义为乘法原理，该原理既是将这种关系进行了抽象化，进行了数学上的定义，其定义的形式既是大家所熟知的$3×2$。 当然，它实际所表达的数学意义其实就是 $3 个 2$ 相加，也就是所有途径之和；然后，乘法原理换了个角度来描述这个问题，从各个步骤的选择方式来进行描述，第一次取出既步骤 $A$ 的可能选择是 $3$，第二次取出既步骤 $B$ 的可能选择是 $2$，那么总体选择 $= 3×2 = 所有途径之和$；笔者通过下面这张概念图来描述了这种关系，步骤 $A 有 3$ 中可能，而步骤 $B 有 2$ 中可能，两者的乘积便是所有途径之和，既是样本空间的大小； 显然，这种规则可以推广到任意多个球，任意多个步骤的情形，笔者这里不再论述；由此可知，加法原理和乘法原理是相容的，只是研究问题的角度不同而已，研究问题的方式其实最终都是加法原理； 总结笔者对上述的原理进一步进行总结，并给出了自己的定义，实际上加法原理的解题思路笔者将其命名为横向思维，考察的就是就是从起点一直到终点的所有途径的可能；而乘法原理的解题思路笔者将其命名为纵向思维，将计算所有从起点到终点途径的可能性的问题转化到了各个步骤上，只需要考察各个步骤的可能性，最终根据乘法原理只需要将各个步骤的可能性相乘便得到所有途径的可能性；因此，乘法原理通过纵向思维将解题办法和思路简化了，而这种简化正是建立在乘法原理对加法原理的抽象上的。 排列和组合从原理上理解了加法原理和乘法原理以后，再来理解排列和组合就容易多了， 排列从$n$个不同元素中任意取 $r(r≤n)$ 个元素排成一列（考虑元素先后出现的次序），称此为一个排列，此种排列的总数记为 P^r_n。按照乘法原理，取出的第一个元素有 $n$ 种取法，取出的第二个元素有 $n−1$ 种取法，……，取出第 $r$ 个元素有 $n−r+1$ 种取法，所以有 $$P^r_n=n×(n−1)×…×(n−r+1)=\frac{n!}{(n−r)!}$$ 若 $r=n$，则称为全排列，记为 $P_n$。显然 $P_n=n!$。 上面便是排列所给出的定义，其实所描述的内容就是乘法原理； 重复排列从 $n$ 个不同元素中每次取出一个，放回后再取下一个，如此连续取 $r$ 次所得的排列称为重复排列，此种重复排列数共有 $nr$ 个。注意：这里的 $r$ 允许大于 $n$； 很好理解，如果要放回，那么每一个步骤既每一次选择都有 $n$ 种可能性，所以，这种情况下，总共的样本点为 $n1×n2×⋯×nr=nr$；还是以乘法原理中的例子为例，好玩的是，一种最为极端的例子，那么有可能三次都取到 1 号球； 组合从 $n$ 个不同元素中任意取 $r(r≤n)$ 个元素并成一组（不考虑元素间的先后次序），称此为一个组合，此中组合的总数记为 $\big(^n_r\big)$ 或 $C^r_n$。按照乘法原理此中组合的总数为$$\Big(^n_r\Big)=\frac{P^r_n}{r!}=\frac{n(n−1)…(n−r+1)}{r!}=\frac{n!}{r!(n−r)!}$$组合也源自于乘法原理，但是它的样本集只是通过乘法原理所得到的所有途径总和的一个子集，因为它不考虑取出结果的顺序，所以它要对结果样本集进行去重；以乘法原理中的例子为例，按照乘法原理，我们得到的结果的全集是 ${ [1, 2]、[1, 3]、[2, 1]、[2, 3]、[3, 1]、[3, 2] }$；如果不考虑取出元素的先后顺序，那么结果集中的 $[1, 2] 和 [2, 1]，[1, 3] 和 [3, 1] 以及 [2, 3] 和 [3, 2]$ 都将视为是同一个结果，所以需要进行去重；去重以后，所得到的结果就是组合的结果，既是 ${ [1, 2]、[1, 3]、[2, 3] }$ 这样包含 3 个结果的样本集；因此可以看到，组合得到的样本集其实是$\frac{乘法原理}{排列}$所得到的样本集的一个子集，这也是组合有别于排列的关键因素； 通过笔者上述的描述，相信大家知道了该如何去重了，但是定义中为什么要将排列的结果除以 $r!$ 呢？不难发现，这样做的目的就是为了去重，但是，背后的规律是什么呢？数学意义或者依据在哪呢？很遗憾，定义中并没有给出，而是直接告诉你除以 $r!$ 就好，笔者不想止步于似懂非懂的层面，那么笔者就试图探究一下这样做背后的数据意义是什么，由此笔者做了如下的推导，假设总共有 $n$ 个元素， 如果取 $2$ 次，假设，去重以后的样本点有 $m$ 个，其中任意一个样本点用 $Ex$ 表示，该样本点可表述为 ${ Ex1,Ex2 }$ 其中 $Ex1,Ex2$ 为该样本点所包含的元素，如果考虑样本点中元素先后取出的顺序，那么要计算出由该样本点所衍生出来的所有样本点（这里指的是交换元素的位置），根据乘法原理，就相当于对该样本点 ${ Ex1,Ex2 }$ 中的元素进行一次全排列既 $P_2$，所以我们得到，由样本点 ${ Ex1,Ex2 }$ 所衍生的所有样本点(包括自己) $= 1×P_2 = 2$ 个，由此我们推广至去重后的所有样本空间既 $m$ 个样本点，均满足该特性，又有，➭ 首先，去重以后的样本空间即组合的样本空间 $=m=\big(^n_r\big)$；➭ 那么，根据上述的规律是否可以求得排列的样本空间呢？显然，排列的样本空间 $P^2_n=P_2×\big(^n_2\big)=2×\big(^n_2\big)$；➥ 由此，我们好像得到了一个非常重要的关系既排列的样本空间 $= Pr×$ 组合的样本空间( r 表示取的次数 )；➥ 但是，这个猜想是否适用于取任意 r 次呢？看下面的例证， 如果取 r 次，同样假设，去重以后的样本点总共有 m 个，其中任意一个样本点用 Ex 表示，该样本点可表述为 {Ex1,Ex2,…,Exr}，那么要求得该样本点所衍生的（通过修改元素先后取出的顺序）所有样本点就相当于对 {Ex1,Ex2,…,Exr} 中的所有元素进行全排列既 Prn，同样，➭ 首先，去重以后的样本空间既组合的样本空间 $=m=\big(^n_r\big)$；➭ 那么，显然，排列的样本空间 $P^r_n=P_r×\big(^n_r\big)=r!×\big(^n_r\big)$；➥ 由此，该关系既排列的样本空间 $= P_r × 组合的样本空间$( $r$ 表示取的次数 ) 成立； 所以，不难发现其背后的一个核心的逻辑，就是$P^r_n=r!×\big(nr\big)$ 其背后的数学意义就是，排列的样本空间就是组合中的每一个样本点通过全排列所得到的样本空间的集合；补充，在遇到实际问题的时候，判断该问题是否是排列还是组合问题，有一个快速的判别方法，问自己，一个样本点中的各个元素的顺序是否可以交换？如果可以交换，则是排列问题，如果不可以交换则是组合问题；因为如果其中的某一个样本点中的元素允许交换位置，那么所有样本点中的元素都可以交换位置，则必然是排列问题。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几何平均数]]></title>
    <url>%2F2019%2F08%2F18%2FgeometricalMean%2F</url>
    <content type="text"><![CDATA[原文链接：https://www.mathsisfun.com/numbers/geometric-mean.html The Geometric Mean is a special type of average where we multiply the numbers together and then take a square root (for two numbers), cube root (for three numbers) etc. Example: What is the Geometric Mean of 2 and 18?First we multiply them: 2 × 18 = 36Then (as there are two numbers) take the square root: √36 = 6In one line: 1Geometric Mean of 2 and 18 = √(2 × 18) = 6 It is like the area is the same! Example: What is the Geometric Mean of 10, 51.2 and 8? First we multiply them: 10 × 51.2 × 8 = 4096Then (as there are three numbers) take the cube root: 3√4096 = 16In one line: 1Geometric Mean = 3√(10 × 51.2 × 8) = 16 It is like the volume is the same: Example: What is the Geometric Mean of 1, 3, 9, 27 and 81?First we multiply them: 1 × 3 × 9 × 27 × 81 = 59049Then (as there are 5 numbers) take the 5th root: 5√59049 = 9In one line: 1Geometric Mean = 5√(1 × 3 × 9 × 27 × 81) = 9 I can’t show you a nice picture of this, but it is still true that: 11 × 3 × 9 × 27 × 81 = 9 × 9 × 9 × 9 × 9 Example: What is the Geometric Mean of a Molecule(分子) and a Mountain Using scientific notation: A molecule of water (for example) is 0.275 × 10-9 mMount Everest (for example) is 8.8 × 103 m 123Geometric Mean = √(0.275 × 10-9 × 8.8 × 103) = √(2.42 × 10-6) ≈ 0.0016 m Which is 1.6 millimeters, or about the thickness of a coin. We could say, in a rough kind of way, “a millimeter is half-way between a molecule and a mountain!”So the geometric mean gives us a way of finding a value in between widely different values. DefinitionFor n numbers: multiply them all together and then take the nth root (written n√ )More formally, the geometric mean of n numbers a1 to an is:1n√(a1 × a2 × ... × an) UsefulThe Geometric Mean is useful when we want to compare things with very different properties. top view cameraExample: you want to buy a new camera.One camera has a zoom of 200 and gets an 8 in reviews,The other has a zoom of 250 and gets a 6 in reviews.Comparing using the usual arithmetic mean gives (200+8)/2 = 104 vs (250+6)/2 = 128. The zoom is such a big number that the user rating gets lost. But the geometric means of the two cameras are:12√(200 × 8) = 40√(250 × 6) = 38.7... So, even though the zoom is 50 bigger, the lower user rating of 6 is still important. 几何平均数的几何意义及与算术平均数的关系的几何解释原文链接：https://baijiahao.baidu.com/s?id=1608753027046746833&amp;wfr=spider&amp;for=pc 我们看两个数的情况。设有两个数a、b，其算术平均数为（a +b）/2，几何平均数为√ab，两者关系为（a+ b）/2≥√ab。下面我们从几何上来理解几何平均数的含义及算术平均数与几何平均数的关系。 如图1，⊿ABD为圆内三角形，AB为直径（故⊿ABD必为直角三角形），DD’垂直于AB，并将AB分成长为a、 b的 两段（注意DD’不一定为直径），现在若已知a,、b 两段的长度，问CD长度为几何？与a 、b有何关系？因为⊿ABD、⊿ACD、⊿CBD均为直角三角形，故此有以下关系：123CD^2+ a^2 = AD^2；CD^2 + b^2 = BD^2；AD^2 + BD^2 = AB^2 =（a+b）^2 于是有：CD^2+ a^2 + CD^2 + b^2= a^2+b^2+2ab等式两边化简，得：CD^2= ab即：CD= √ab。另外，由上图可见，（a +b）/2 ≥ √ab（仅当DD’为直径时相等）。问题得以证明。 算术平均数 vs 几何平均数原文链接：https://zhuanlan.zhihu.com/p/23809612 首先明确一点，几何平均数和算数平均数其实都是一种衡量平均水平的统计方法，之所以计算方法有差别，是因为数据类型的不同导致。 无论任何平均数，其意义都是：对于数列用某一个常数A将数列中的每一项替换，形成的新数列结果上与旧数列等效。这个常数A，就是数列An的平均数。 那么什么时候用算数平均数什么时候用几何平均数呢，我们来考虑以下的情形：你发现最近二师兄（猪肉）身价猛涨，于是投入了10万元本金开始卖猪肉，果然第一年赚得盆满钵满的，赚了5万元，本金变成了10+5=15万元。但是好景不长，商品的供需周期的变化，第二年的时候很多猪肉供应商开始进入猪肉市场，供应的大量增加导致猪肉价格快速下跌，第二年亏了7.5万元，本金变成了15-7.5=7.5万元。 现在我们想计算下述两个平均数： 1. 两年利润的平均数这种类型的平均数最终结果是一个和，第一年利润是5万元，第二年利润是-7.5万元，最终结果是亏了2.5万元，年均亏1.25万元。两年赚的钱构成的数列{A1,A2}根据平均数的定义，为构造一个数列与其等效{A,A}那么这个等效数列万元也就是第一年赚5万元并且第二年亏7.5万元和两年都亏1.25万元等效。 2. 两年本金变化的平均数这种类型的平均数最终结果是一个积，第一年初本金是10万元，第一年末变成15万元增长到了1.5倍，第二年末变成7.5万元下降到了0.5倍。两年本金增长倍数{A1,A2}根据平均数的定义，为构造一个数列与其等效{A,A}那么这个等效数列也就是第一年本金增长到1.5倍并且第二年下降到0.5倍和两年都下降到0.87倍等效。 总结来说，当数据最终结果是一个和时，用算术平均数更合适，当数据最终结果是一个积时，用几何平均数更加合适。所以一般在算增长率的时候，用几何平均数更加合适。 算术平均数几何平均数 注意几何平均数里如果是增长率的话用的公式是 例如上述例题中增长率如果平均数用得不合适，容易导致荒谬的结论。举个例子，假如一只股票价格第一年初价格为10元，第一年增长了100%变成了20元，第二年下降了50%变成了10元，在算平均增长率时 几何平均数 算数平均数 几何平均数才是更加合理的答案，因为这个股票第一年初价格为10元，第二年末价格也是10元，增长率为0%，算术平均数算出来的75%就显得很荒谬。 后记： 平均数还有一种叫做调和平均数，计算公式为：适用的例子是我们初中物理中学到的并联电路中各个并联电阻构成的电路总电阻的计算。各电阻为A1,A2,…,An并联和A,A,…,A并联构成的电路总电阻等效。 根据不等式的性质可以证明：算术平均数 &gt; 几何平均数 &gt; 调和平均数]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>几何平均数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数的本质]]></title>
    <url>%2F2019%2F08%2F12%2FlinearAlgebra%2F</url>
    <content type="text"><![CDATA[理解矩阵（一）原文链接：http://blog.csdn.net/myan/article/details/647511 前不久chensh出于不可告人的目的，要充当老师，教别人线性代数。于是我被揪住就线性代数中一些务虚性的问题与他讨论了几次。很明显，chensh觉得，要让自己在讲线性代数的时候不被那位强势的学生认为是神经病，还是比较难的事情。 可怜的chensh，谁让你趟这个地雷阵？！色令智昏啊！ 线性代数课程，无论你从行列式入手还是直接从矩阵入手，从一开始就充斥着莫名其妙。比如说，在全国一般工科院系教学中应用最广泛的同济线性代数教材（现在到了第四版），一上来就介绍逆序数这个古怪概念，然后用逆序数给出行列式的一个极不直观的定义，接着是一些简直犯傻的行列式性质和习题——把这行乘一个系数加到另一行上，再把那一列减过来，折腾得那叫一个热闹，可就是压根看不出这个东西有嘛用。 大多数像我一样资质平庸的学生到这里就有点犯晕：连这是个什么东西都模模糊糊的，就开始钻火圈表演了，这未免太无厘头了吧！于是开始有人逃课，更多的人开始抄作业。这下就中招了，因为其后的发展可以用一句峰回路转来形容，紧跟着这个无厘头的行列式的，是一个同样无厘头但是伟大的无以复加的家伙的出场——矩阵来了！多年之后，我才明白，当老师犯傻似地用中括号把一堆傻了吧叽的数括起来，并且不紧不慢地说：“这个东西叫做矩阵”的时候，我的数学生涯掀开了何等悲壮辛酸、惨绝人寰的一幕！自那以后，在几乎所有跟“学问”二字稍微沾点边的东西里，矩阵这个家伙从不缺席。对于我这个没能一次搞定线性代数的笨蛋来说，矩阵老大的不请自来每每搞得我灰头土脸，头破血流。长期以来，我在阅读中一见矩阵，就如同阿Q见到了假洋鬼子，揉揉额角就绕道走。 事实上，我并不是特例。一般工科学生初学线性代数，通常都会感到困难。这种情形在国内外皆然。瑞典数学家Lars Garding在其名著Encounter with Mathematics中说：“如果不熟悉线性代数的概念，要去学习自然科学，现在看来就和文盲差不多。然而“按照现行的国际标准，线性代数是通过公理化来表述的，它是第二代数学模型，这就带来了教学上的困难。”事实上，当我们开始学习线性代数的时候，不知不觉就进入了“第二代数学模型”的范畴当中，这意味着数学的表述方式和抽象性有了一次全面的进化，对于从小一直在“第一代数学模型”，即以实用为导向的、具体的数学模型中学习的我们来说，在没有并明确告知的情况下进行如此剧烈的paradigm shift，不感到困难才是奇怪的。 大部分工科学生，往往是在学习了一些后继课程，如数值分析、数学规划、矩阵论之后，才逐渐能够理解和熟练运用线性代数。即便如此，不少人即使能够很熟练地以线性代数为工具进行科研和应用工作，但对于很多这门课程的初学者提出的、看上去是很基础的问题却并不清楚。比如说： 1、矩阵究竟是什么东西？ 2、向量可以被认为是具有n个相互独立的性质（维度）的对象的表示，矩阵又是什么呢？ 3、我们如果认为矩阵是一组列（行）向量组成的新的复合向量的展开式，那么为什么这种展开式具有如此广泛的应用？特别是，为什么偏偏二维的展开式如此有用？ 4、如果矩阵中每一个元素又是一个向量，那么我们再展开一次，变成三维的立方阵，是不是更有用？ 5、矩阵的乘法规则究竟为什么这样规定？为什么这样一种怪异的乘法规则却能够在实践中发挥如此巨大的功效？很多看上去似乎是完全不相关的问题，最后竟然都归结到矩阵的乘法，这难道不是很奇妙的事情？难道在矩阵乘法那看上去莫名其妙的规则下面，包含着世界的某些本质规律？如果是的话，这些本质规律是什么？ 6、行列式究竟是一个什么东西？为什么会有如此怪异的计算规则？行列式与其对应方阵本质上是什么关系？为什么只有方阵才有对应的行列式，而一般矩阵就没有（不要觉得这个问题很蠢，如果必要，针对mxn矩阵定义行列式不是做不到的，之所以不做，是因为没有这个必要，但是为什么没有这个必要）？而且，行列式的计算规则，看上去跟矩阵的任何计算规则都没有直观的联系，为什么又在很多方面决定了矩阵的性质？难道这一切仅是巧合？ 7、矩阵为什么可以分块计算？分块计算这件事情看上去是那么随意，为什么竟是可行的？ 8、对于矩阵转置运算AT，有(AB)T=BTAT，对于矩阵求逆运算A-1，有(AB)-1=B-1A-1。两个看上去完全没有什么关系的运算，为什么有着类似的性质？这仅仅是巧合吗？ 9、为什么说P−1AP得到的矩阵与A矩阵“相似”？这里的“相似”是什么意思？ 10、特征值和特征向量的本质是什么？它们定义就让人很惊讶，因为Ax=λx，一个诺大的矩阵的效应，竟然不过相当于一个小小的数λ，确实有点奇妙。但何至于用“特征”甚至“本征”来界定？它们刻划的究竟是什么？ 这样的一类问题，经常让使用线性代数已经很多年的人都感到为难。就好像大人面对小孩子的刨根问底，最后总会迫不得已地说“就这样吧，到此为止”一样，面对这样的问题，很多老手们最后也只能用：“就是这么规定的，你接受并且记住就好”来搪塞。 然而，这样的问题如果不能获得回答，线性代数对于我们来说就是一个粗暴的、不讲道理的、莫名其妙的规则集合，我们会感到，自己并不是在学习一门学问，而是被不由分说地“抛到”一个强制的世界中，只是在考试的皮鞭挥舞之下被迫赶路，全然无法领略其中的美妙、和谐与统一。直到多年以后，我们已经发觉这门学问如此的有用，却仍然会非常迷惑：怎么这么凑巧？我认为这是我们的线性代数教学中直觉性丧失的后果。上述这些涉及到“如何能”、“怎么会”的问题，仅仅通过纯粹的数学证明来回答，是不能令提问者满意的。比如，如果你通过一般的证明方法论证了矩阵分块运算确实可行，那么这并不能够让提问者的疑惑得到解决。他们真正的困惑是：矩阵分块运算为什么竟然是可行的？究竟只是凑巧，还是说这是由矩阵这种对象的某种本质所必然决定的？如果是后者，那么矩阵的这些本质是什么？只要对上述那些问题稍加考虑，我们就会发现，所有这些问题都不是单纯依靠数学证明所能够解决的。像我们的教科书那样，凡事用数学证明，最后培养出来的学生，只能熟练地使用工具，却欠缺真正意义上的理解。 自从1930年代法国布尔巴基学派兴起以来，数学的公理化、系统性描述已经获得巨大的成功，这使得我们接受的数学教育在严谨性上大大提高。然而数学公理化的一个备受争议的副作用，就是一般数学教育中直觉性的丧失。数学家们似乎认为直觉性与抽象性是矛盾的，因此毫不犹豫地牺牲掉前者。然而包括我本人在内的很多人都对此表示怀疑，我们不认为直觉性与抽象性一定相互矛盾，特别是在数学教育中和数学教材中，帮助学生建立直觉，有助于它们理解那些抽象的概念，进而理解数学的本质。反之，如果一味注重形式上的严格性，学生就好像被迫进行钻火圈表演的小白鼠一样，变成枯燥的规则的奴隶。 对于线性代数的类似上述所提到的一些直觉性的问题，两年多来我断断续续地反复思考了四、五次，为此阅读了好几本国内外线性代数、数值分析、代数和数学通论性书籍，其中像前苏联的名著《数学：它的内容、方法和意义》、龚昇教授的《线性代数五讲》、前面提到的Encounter with Mathematics（《数学概观》）以及Thomas A. Garrity的《数学拾遗》都给我很大的启发。不过即使如此，我对这个主题的认识也经历了好几次自我否定。比如以前思考的一些结论曾经写在自己的blog里，但是现在看来，这些结论基本上都是错误的。因此打算把自己现在的有关理解比较完整地记录下来，一方面是因为我觉得现在的理解比较成熟了，可以拿出来与别人探讨，向别人请教。另一方面，如果以后再有进一步的认识，把现在的理解给推翻了，那现在写的这个snapshot也是很有意义的。 线性空间今天先谈谈对线形空间和矩阵的几个核心概念的理解。这些东西大部分是凭着自己的理解写出来的，基本上不抄书，可能有错误的地方，希望能够被指出。但我希望做到直觉，也就是说能把数学背后说的实质问题说出来。 首先说说空间(space)，这个概念是现代数学的命根子之一，从拓扑空间开始，一步步往上加定义，可以形成很多空间。线形空间其实还是比较初级的，如果在里面定义了范数，就成了赋范线性空间。赋范线性空间满足完备性，就成了巴那赫空间；赋范线性空间中定义角度，就有了内积空间，内积空间再满足完备性，就得到希尔伯特空间。总之，空间有很多种。你要是去看某种空间的数学定义，大致都是：存在一个集合，在这个集合上定义某某概念，然后满足某些性质，就可以被称为空间。这未免有点奇怪，为什么要用“空间”来称呼一些这样的集合呢？大家将会看到，其实这是很有道理的。我们一般人最熟悉的空间，毫无疑问就是我们生活在其中的（按照牛顿的绝对时空观）的三维空间，从数学上说，这是一个三维的欧几里德空间，我们先不管那么多，先看看我们熟悉的这样一个空间有些什么最基本的特点。仔细想想我们就会知道，这个三维的空间： 1.由很多（实际上是无穷多个）位置点组成； 2.这些点之间存在相对的关系； 3.可以在空间中定义长度、角度； 4.这个空间可以容纳运动，这里我们所说的运动是从一个点到另一个点的移动（变换），而不是微积分意义上的“连续”性的运动。 上面的这些性质中，最最关键的是第4条。第1、2条只能说是空间的基础，不算是空间特有的性质，凡是讨论数学问题，都得有一个集合，大多数还得在这个集合上定义一些结构（关系），并不是说有了这些就算是空间。而第3条太特殊，其他的空间不需要具备，更不是关键的性质。只有第4条是空间的本质，也就是说，容纳运动是空间的本质特征。认识到了这些，我们就可以把我们关于三维空间的认识扩展到其他的空间。事实上，不管是什么空间，都必须容纳和支持在其中发生的符合规则的运动（变换）。你会发现，在某种空间中往往会存在一种相对应的变换，比如拓扑空间中有拓扑变换，线性空间中有线性变换，仿射空间中有仿射变换，其实这些变换都只不过是对应空间中允许的运动形式而已。 因此只要知道，“空间”是容纳运动的一个对象集合，而变换则规定了对应空间的运动。 下面我们来看看线性空间。线性空间的定义任何一本书上都有，但是既然我们承认线性空间是个空间，那么有两个最基本的问题必须首先得到解决，那就是： 1.空间是一个对象集合，线性空间也是空间，所以也是一个对象集合。那么线性空间是什么样的对象的集合？或者说，线性空间中的对象有什么共同点吗？ 2.线性空间中的运动如何表述的？也就是，线性变换是如何表示的？ 我们先来回答第一个问题，回答这个问题的时候其实是不用拐弯抹角的，可以直截了当的给出答案：线性空间中的任何一个对象，通过选取基和坐标的办法，都可以表达为向量的形式。通常的向量空间我就不说了，举两个不那么平凡的例子： 1、L1是最高次项不大于n次的多项式的全体构成一个线性空间，也就是说，这个线性空间中的每一个对象是一个多项式。如果我们以x0,x1,…,xn为基，那么任何一个这样的多项式都可以表达为一组n+1维向量，其中的每一个分量ai其实就是多项式中xi−1项的系数。值得说明的是，基的选取有多种办法，只要所选取的那一组基线性无关就可以。这要用到后面提到的概念了，所以这里先不说，提一下而已。 2、L2是闭区间[a, b]上的n阶连续可微函数的全体，构成一个线性空间。也就是说，这个线性空间的每一个对象是一个连续函数。对于其中任何一个连续函数，根据魏尔斯特拉斯定理，一定可以找到最高次项不大于n的多项式函数，使之与该连续函数的差为0，也就是说，完全相等。这样就把问题归结为L1了。后面就不用再重复了。 所以说， 向量是很厉害的，只要你找到合适的基，用向量可以表示线性空间里任何一个对象。这里头大有文章，因为向量表面上只是一列数，但是其实由于它的有序性，所以除了这些数本身携带的信息之外，还可以在每个数的对应位置上携带信息。为什么在程序设计中数组最简单，却又威力无穷呢？根本原因就在于此。这是另一个问题了，这里就不说了。 下面来回答第二个问题，这个问题的回答会涉及到线性代数的一个最根本的问题。线性空间中的运动，被称为线性变换。也就是说，你从线性空间中的一个点运动到任意的另外一个点，都可以通过一个线性变化来完成。那么，线性变换如何表示呢？很有意思，在线性空间中，当你选定一组基之后，不仅可以用一个向量来描述空间中的任何一个对象，而且可以用矩阵来描述该空间中的任何一个运动（变换）。而使某个对象发生对应运动的方法，就是用代表那个运动的矩阵，乘以代表那个对象的向量。简而言之，在线性空间中选定基之后，向量刻画对象，矩阵刻画对象的运动，用矩阵与向量的乘法施加运动。是的，矩阵的本质是运动的描述。 如果以后有人问你矩阵是什么，那么你就可以响亮地告诉他，矩阵的本质是运动的描述。 可是多么有意思啊，向量本身不是也可以看成是n x 1矩阵吗？这实在是很奇妙，一个空间中的对象和运动竟然可以用相类同的方式表示。能说这是巧合吗？如果是巧合的话，那可真是幸运的巧合！可以说，线性代数中大多数奇妙的性质，均与这个巧合有直接的关系。 理解矩阵（二）原文链接：http://blog.csdn.net/myan/article/details/649018 接着理解矩阵，上面说“矩阵是运动的描述”，到现在为止，好像大家都还没什么意见。但是我相信早晚会有数学系出身的网友来拍板转。因为运动这个概念，在数学和物理里是跟微积分联系在一起的。我们学习微积分的时候，总会有人照本宣科地告诉你，初等数学是研究常量的数学，是研究静态的数学，高等数学是变量的数学，是研究运动的数学。大家口口相传，差不多人人都知道这句话。但是真知道这句话说的是什么意思的人，好像也不多。 因为这篇文章不是讲微积分的，所以我就不多说了。有兴趣的读者可以去看看齐民友教授写的《重温微积分》。我就是读了这本书开头的部分，才明白“高等数学是研究运动的数学”这句话的道理。不过在我这个《理解矩阵》的文章里，“运动”的概念不是微积分中的连续性的运动，而是瞬间发生的变化。比如这个时刻在A点，经过一个“运动”，一下子就“跃迁”到了B点，其中不需要经过A点与B点之间的任何一个点。这样的“运动”，或者说“跃迁”，是违反我们日常的经验的。不过了解一点量子物理常识的人，就会立刻指出，量子（例如电子）在不同的能量级轨道上跳跃，就是瞬间发生的，具有这样一种跃迁行为。所以说，自然界中并不是没有这种运动现象，只不过宏观上我们观察不到。但是不管怎么说，“运动”这个词用在这里，还是容易产生歧义的，说得更确切些，应该是“跃迁”。因此这句话可以改成：“矩阵是线性空间里跃迁的描述”。可是这样说又太物理，也就是说太具体，而不够数学，也就是说不够抽象。因此我们最后换用一个正牌的数学术语——变换，来描述这个事情。这样一说，大家就应该明白了，所谓变换，其实就是空间里从一个点（元素/对象）到另一个点（元素/对象）的跃迁。比如说，仿射变换，就是在仿射空间里从一个点到另一个点的跃迁。 附带说一下，这个仿射空间跟向量空间是亲兄弟。做计算机图形学的朋友都知道，尽管描述一个三维对象只需要三维向量，但所有的计算机图形学变换矩阵都是4x4的。说其原因，很多书上都写着“为了使用中方便”，这在我看来简直就是企图蒙混过关。真正的原因，是因为在计算机图形学里应用的图形变换，实际上是在仿射空间而不是向量空间中进行的。想想看，在向量空间里相一个向量平行移动以后仍是相同的那个向量，而现实世界等长的两个平行线段当然不能被认为同一个东西，所 以计算机图形学的生存空间实际上是仿射空间。而仿射变换的矩阵表示根本就是4x4的。有兴趣的读者可以去看《计算机图形学——几何工具算法详解》。 一旦我们理解了“变换”这个概念，矩阵的定义就变成：矩阵是线性空间里的变换的描述。到这里为止，我们终于得到了一个看上去比较数学的定义。不过还要多说几句。教材上一般是这么说的，在一个线性空间V里的一个线性变换T，当选定一组基之后，就可以表示为矩阵。因此我们还要说清楚到底什么是线性变换，什么是基，什么叫选定一组基。线性变换的定义是很简单的，设有一种变换T，使得对于线性空间V中间任何两个不相同的对象x和y，以及任意实数a和b，有：T(ax+by)=aT(x)+bT(y)，那么就称T为线性变换。定义都是这么写的，但是光看定义还得不到直觉的理解。线性变换究竟是一种什么样的变换？我们刚才说了，变换是从空间的一个点跃迁到另一个点，而线性变换，就是从一个线性空间V的某一个点跃迁到另一个线性空间W的另一个点的运动。这句话里蕴含着一层意思，就是说一个点不仅可以变换到同一个线性空间中的另一个点，而且可以变换到另一个线性空间中的另一个点去。不管你怎么变，只要变换前后都是线性空间中的对象，这个变换就一定是线性变换，也就一定可以用一个非奇异矩阵来描述。而你用一个非奇异矩阵去描述的一个变换，一定是一个线性变换。 有的人可能要问，这里为什么要强调非奇异矩阵？所谓非奇异，只对方阵有意义，那么非方阵的情况怎么样？这个说起来就会比较冗长了，最后要把线性变换作为一种映射，并且讨论其映射性质，以及线性变换的核与像等概念才能彻底讲清楚。 以下我们只探讨最常用、最有用的一种变换，就是在同一个线性空间之内的线性变换。也就是说，下面所说的矩阵，不作说明的话，就是方阵，而且是非奇异方阵。学习一门学问，最重要的是把握主干内容，迅速建立对于这门学问的整体概念，不必一开始就考虑所有的细枝末节和特殊情况，自乱阵脚。 什么是基呢？这个问题在后面还要大讲一番，这里只要把基看成是线性空间里的坐标系就可以了。注意是坐标系，不是坐标值，这两者可是一个“对立矛盾统一体”。这样一来，“选定一组基”就是说在线性空间里选定一个坐标系。好，最后我们把矩阵的定义完善如下：“矩阵是线性空间中的线性变换的一个描述。在一个线性空间中，只要我们选定一组基，那么对于任何一个线性变换，都能够用一个确定的矩阵来加以描述。”理解这句话的关键，在于把“线性变换”与“线性变换的一个描述”区别开。一个是那个对象，一个是对那个对象的表述。就好像我们熟悉的面向对象编程中，一个对象可以有多个引用，每个引用可以叫不同的名字，但都是指的同一个对象。如果还不形象，那就干脆来个很俗的类比。比如有一头猪，你打算给它拍照片，只要你给照相机选定了一个镜头位置，那么就可以给这头猪拍一张照片。这个照片可以看成是这头猪的一个描述，但只是一个片面的的描述，因为换一个镜头位置给这头猪拍照，能得到一张不同的照片，也是这头猪的另一个片面的描述。所有这样照出来的照片都是这同一头猪的描述，但是又都不是这头猪本身。同样的，对于一个线性变换，只要你选定一组基，那么就可以找到一个矩阵来描述这个线性变换。换一组基，就得到一个不同的矩阵。所有这些矩阵都是这同一个线性变换的描述，但又都不是线性变换本身。 但是这样的话，问题就来了如果你给我两张猪的照片，我怎么知道这两张照片上的是同一头猪呢？同样的，你给我两个矩阵，我怎么知道这两个矩阵是描述的同一个线性变换呢？如果是同一个线性变换的不同的矩阵描述，那就是本家兄弟了，见面不认识，岂不成了笑话。好在，我们可以找到同一个线性变换的矩阵兄弟们的一个性质，那就是：若矩阵A与B是同一个线性变换的两个不同的描述（之所以会不同，是因为选定了不同的基，也就是选定了不同的坐标系），则一定能找到一个非奇异矩阵P，使得A、B之间满足这样的关系：A=P−1BP。线性代数稍微熟一点的读者一下就看出来，这就是相似矩阵的定义。没错，所谓相似矩阵，就是同一个线性变换的不同的描述矩阵。按照这个定义，同一头猪的不同角度的照片也可以成为相似照片。俗了一点，不过能让人明白。而在上面式子里那个矩阵P，其实就是A矩阵所基于的基与B矩阵所基于的基这两组基之间的一个变换关系。 关于这个结论，可以用一种非常直觉的方法来证明（而不是一般教科书上那种形式上的证明），如果有时间的话，我以后在blog里补充这个证明。这个发现太重要了。原来一族相似矩阵都是同一个线性变换的描述啊！难怪这么重要！工科研究生课程中有矩阵论、矩阵分析等课程，其中讲了各种各样的相似变换，比如什么相似标准型，对角化之类的内容，都要求变换以后得到的那个矩阵与先前的那个矩阵式相似的，为什么这么要求？因为只有这样要求，才能保证变换前后的两个矩阵是描述同一个线性变换的。 当然，同一个线性变换的不同矩阵描述，从实际运算性质来看并不是不分好环的。有些描述矩阵就比其他的矩阵性质好得多。这很容易理解，同一头猪的照片也有美丑之分嘛。所以矩阵的相似变换可以把一个比较丑的矩阵变成一个比较美的矩阵，而保证这两个矩阵都是描述了同一个线性变换。这样一来，矩阵作为线性变换描述的一面，基本上说清楚了。但是，事情没有那么简单，或者说，线性代数还有比这更奇妙的性质，那就是，矩阵不仅可以作为线性变换的描述，而且可以作为一组基的描述。而作为变换的矩阵，不但可以把线性空间中的一个点给变换到另一个点去，而且也能够把线性空间中的一个坐标系（基）表换到另一个坐标系（基）去。而且，变换点与变换坐标系，具有异曲同工的效果。线性代数里最有趣的奥妙，就蕴含在其中。理解了这些内容，线性代数里很多定理和规则会变得更加清晰、直觉。 这个留在下一篇再写吧。 因为有别的事情要做，下一篇可能要过几天再写了。 理解矩阵（三）原文链接：http://blog.csdn.net/myan/article/details/1865397 在第二部分结束的时候，我说：“矩阵不仅可以作为线性变换的描述，而且可以作为一组基的描述。而 作为变换的矩阵，不但可以把线性空间中的一个点给变换到另一个点去，而且也能够把线性空间中的一个坐标系（基）表换到另一个坐标系（基）去。而且，变换点 与变换坐标系，具有异曲同工的效果。线性代数里最有趣的奥妙，就蕴含在其中。理解了这些内容，线性代数里很多定理和规则会变得更加清晰、直觉。这个留在下一篇再写吧。因为有别的事情要做，下一篇可能要过几天再写了。 ” 然而这一拖就是一年半。一年半以来，这两篇粗糙放肆的文章被到处转载，以至于在Google的搜索提示中，我的名字跟“矩阵”是一对关联词汇。这对于学生时代数学一直很差的我来说，实在是令人惶恐的事情。数学是何等辉煌精致的学问！代表着人类智慧的最高成就，是人与上帝对话的语言。而我实在连数学的门都还没进去，不要说谈什么理解，就是稍微难一些的题目我也很少能解开。我有什么资格去谈矩阵这样重要的一个数学概念呢？更何况，我的想法直观是直观，未见的是正确的啊，会不会误人子弟呢？因此，算了吧，到此为止吧，我这么想。 是时不时收到的来信逐渐改变了我的想法。 一年半以来，我收到过不下一百封直接的来信，要求我把后面的部分写出来。这些来信大部分是国内的网友和学生，也有少数来自正在国外深造的朋友，大部分是鼓励，有的是诚挚的请求，也有少数严厉斥责我不守承诺。不管是何种态度，这都表明他们对我这一点点小小的思考成果的鼓励，特别是对于我这种思维的视角和尝试的鼓励。他们在信中让我知道，尽管我的数学水平不高，但是我这种从普通人（而不是数学家）视角出发，强调对数学概念和规则的直觉理解的思路，对于很多人是有益的。也许这条路子在数学中绝非正道，也不会走得很远，但是无论如何，在一定的阶段，对一部分人来说，较之目前数学教材普遍采用的思路，这种方式可能更容易理解一些。既然是可能对一部分人有帮助的事情，那么我就不应该心存太多杂念，应该不断思考和总结下去。 所以，下面就是你们来信要求我写出来的东西。 首先来总结一下前面部分的一些主要结论： 1.首先有空间，空间可以容纳对象运动的。一种空间对应一类对象。 2.有一种空间叫线性空间，线性空间是容纳向量对象运动的。 3.运动是瞬时的，因此也被称为变换。 4.矩阵是线性空间中运动（变换）的描述。 5.矩阵与向量相乘，就是实施运动（变换）的过程。 6.同一个变换，在不同的坐标系下表现为不同的矩阵，但是它们的本质是一样的，所以本征值相同。 下面让我们把视力集中到一点以改变我们以往看待矩阵的方式。我们知道，线性空间里的基本对象是向量。 向量是这么表示的：[a1,a2,a3,…,an]。矩阵是这么表示的：a11,a12,a13,…,a1n,a21,a22,a23,…,a2n,…,an1,an2,an3,…,ann不用太聪明，我们就能看出来，矩阵是一组向量组成的。特别的，n维线性空间里的方阵是由n个n维向量组成的。我们在这里只讨论这个n阶的、非奇异的方阵，因为理解它就是理解矩阵的关键，它才是一般情况，而其他矩阵都是意外，都是不得不对付的讨厌状况，大可以放在一边。这里多一句嘴，学习东西要抓住主流，不要纠缠于旁支末节。很可惜我们的教材课本大多数都是把主线埋没在细节中的，搞得大家还没明白怎么回事就先被灌晕了。比如数学分析，明明最要紧的观念是说，一个对象可以表达为无穷多个合理选择的对象的线性和，这个概念是贯穿始终的，也是数学分析的精华。但是课本里自始至终不讲这句话，反正就是让你做吉米多维奇，掌握一大堆解偏题的技巧，记住各种特殊情况，两类间断点，怪异的可微和可积条件（谁还记得柯西条件、迪里赫莱条件…？），最后考试一过，一切忘光光。要我说，还不如反复强调这一个事情，把它深深刻在脑子里，别的东西忘了就忘了，真碰到问题了，再查数学手册嘛，何必因小失大呢？ 言归正传，如果一组向量是彼此线性无关的话，那么它们就可以成为度量这个线性空间的一组基，从而事实上成为一个坐标系体系，其中每一个向量都躺在一根坐标轴上，并且成为那根坐标轴上的基本度量单位（长度1）。现在到了关键的一步。看上去矩阵就是由一组向量组成的，而且如果矩阵非奇异的话（我说了，只考虑这种情况），那么组成这个矩阵的那一组向量也就是线性无关的了，也就可以成为度量线性空间的一个坐标系。结论：矩阵描述了一个坐标系。“慢着！”，你嚷嚷起来了，“你这个骗子！你不是说过，矩阵就是运动吗？怎么这会矩阵又是坐标系了？”嗯，所以我说到了关键的一步。我并没有骗人，之所以矩阵又是运动，又是坐标系，那是因为——“运动等价于坐标系变换”。对不起，这话其实不准确，我只是想让你印象深刻。准确的说法是：“对象的变换等价于坐标系的变换”。或者：“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换。”说白了就是：“运动是相对的。” 让我们想想，达成同一个变换的结果，比如把点(1,1)变到点(2,3)去，你可以有两种做法。第一，坐标系不动，点动，把(1,1)点挪到(2,3)去。第二，点不动，变坐标系，让x轴的度量（单位向量）变成原来的1/2，让y轴的度量（单位向量）变成原先的1/3，这样点还是那个点，可是点的坐标就变成(2,3)了。方式不同，结果一样。从第一个方式来看，那就是把矩阵看成是运动描述，矩阵与向量相乘就是使向量（点）运动的过程。在这个方式下，Ma=b的意思是：“向量a经过矩阵M所描述的变换，变成了向量b。”而从第二个方式来看，矩阵M描述了一个坐标系，姑且也称之为M。那么：Ma=b的意思是：“有一个向量，它在坐标系M的度量下得到的度量结果向量为a，那么它在坐标系I的度量下，这个向量的度量结果是b。”这里的I是指单位矩阵，就是主对角线是1，其他为零的矩阵。而这两个方式本质上是等价的。我希望你务必理解这一点，因为这是本篇的关键。正因为是关键，所以我得再解释一下。在M为坐标系的意义下，如果把M放在一个向量a的前面，形成Ma的样式，我们可以认为这是对向量a的一个环境声明。它相当于是说：“注意了！这里有一个向量，它在坐标系M中度量，得到的度量结果可以表达为a。可是它在别的坐标系里度量的话，就会得到不同的结果。为了明确，我把M放在前面，让你明白，这是该向量在坐标系M中度量的结果。” 那么我们再看孤零零的向量b：b多看几遍，你没看出来吗？它其实不是b，它是：Ib也就是说：“在单位坐标系，也就是我们通常说的直角坐标系I中，有一个向量，度量的结果是b。”而Ma=Ib的意思就是说：“在M坐标系里量出来的向量a，跟在I坐标系里量出来的向量b，其实根本就是一个向量啊！”这哪里是什么乘法计算，根本就是身份识别嘛。从这个意义上我们重新理解一下向量。向量这个东西客观存在，但是要把它表示出来，就要把它放在一个坐标系中去度量它，然后把度量的结果（向量在各个坐标轴上的投影值）按一定顺序列在一起，就成了我们平时所见的向量表示形式。你选择的坐标系（基）不同，得出来的向量的表示就不同。向量还是那个向量，选择的坐标系不同，其表示方式就不同。因此，按道理来说，每写出一个向量的表示，都应该声明一下这个表示是在哪个坐标系中度量出来的。表示的方式，就是Ma，也就是说，有一个向量，在M矩阵表示的坐标系中度量出来的结果为a。 回过头来说变换的问题，我刚才说，“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换”，那个“固定对象”我们找到了，就是那个向量。但是坐标系的变换呢？我怎么没看见？请看：Ma=Ib我现在要变M为I，怎么变？对了，再前面乘以个M-1，也就是M的逆矩阵。换句话说，你不是有一个坐标系M吗，现在我让它乘以个M-1，变成I，这样一来的话，原来M坐标系中的a在I中一量，就得到b了。我建议你此时此刻拿起纸笔，画画图，求得对这件事情的理解。比如，你画一个坐标系，x轴上的衡量单位是2，y轴上的衡量单位是3，在这样一个坐标系里，坐标为(1,1)的那一点，实际上就是笛卡尔坐标系里的点(2,3)。而让它原形毕露的办法，就是把原来那个坐标系:[2,0,0,3]T 的x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3，这样一来坐标系就变成单位坐标系I了。保持点不变，那个向量现在就变成了(2, 3)了。 怎么能够让“x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3”呢？就是让原坐标系：[2,0,0,3] 被矩阵[1/2,0,0,1/3]T 左乘。而这个矩阵就是原矩阵的逆矩阵。 下面我们得出一个重要的结论：“对坐标系施加变换的方法，就是让表示那个坐标系的矩阵与表示那个变化的矩阵相乘。”再一次的，矩阵的乘法变成了运动的施加。只不过，被施加运动的不再是向量，而是另一个坐标系。如果你觉得你还搞得清楚，请再想一下刚才已经提到的结论，矩阵MxN，一方面表明坐标系N在运动M下的变换结果，另一方面，把M当成N的前缀，当成N的环境描述，那么就是说，在M坐标系度量下，有另一个坐标系N。这个坐标系N如果放在I坐标系中度量，其结果为坐标系MxN。 在这里，我实际上已经回答了一般人在学习线性代数是最困惑的一个问题，那就是为什么矩阵的乘法要规定成这样。简单地说，是因为： 1.从变换的观点看，对坐标系N施加M变换，就是把组成坐标系N的每一个向量施加M变换。 2.从坐标系的观点看，在M坐标系中表现为N的另一个坐标系，这也归结为，对N坐标系基的每一个向量，把它在I坐标系中的坐标找出来，然后汇成一个新的矩阵。 3.至于矩阵乘以向量为什么要那样规定，那是因为一个在M中度量为a的向量，如果想要恢复在I中的真像，就必须分别与M中的每一个向量进行內积运算。 我把这个结论的推导留给感兴趣的朋友吧。综合以上，矩阵的乘法就得那么规定，一切有根有据，绝不是哪个神经病胡思乱想出来的。我们伟大的线性代数课本上说的矩阵定义，是无比正确的：“矩阵就是由m行n列数放在一起组成的数学对象。” 好了，这基本上就是我想说的全部了。还留下一个行列式的问题。矩阵M的行列式实际上是组成M的各个向量按照平行四边形法则搭成一个n维立方体的体积。对于这一点，我只能感叹于其精妙，却无法揭开其中奥秘了。也许我掌握的数学工具不够，我希望有人能够给我们大家讲解其中的道理了。 我不知道是否讲得足够清楚了，反正这一部分需要您花些功夫去推敲。 此外，请大家不必等待这个系列的后续部分。以我的工作情况而言，近期内很难保证继续投入脑力到这个领域中，尽管我仍然对此兴致浓厚。不过如果还有（四）的话，可能是一些站在应用层面的考虑，比如对计算机图形学相关算法的理解。但是我不承诺这些讨论近期内会出现了。 本文原文是孟岩在csdn上发表的三篇博客：理解矩阵（一），理解矩阵（二）， 理解矩阵（三）]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写了个前端组件库 - zhaKU]]></title>
    <url>%2F2019%2F04%2F20%2Fzhaku%2F</url>
    <content type="text"><![CDATA[zhaKU文档地址 基于vue 2.x开发的UI组件库，轻量，简洁。 图标库基于手机淘宝图标库 安装：1npm install --save zhaku 引入：12import zhaku from 'zhaku';const &#123;Button, Input&#125; from 'zhaku'; 全局引入：1234import Vue from 'vue';import zhaku from 'zhaku';Vue.use(zhaku); 全局引入后，在模版里使用，只需用小写字母z加组件名，并用-连接。 例如：&lt;z-button&gt;这个是按钮&lt;/z-button&gt;。 后续将完善更多的组件。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在这做一些日常搜索的笔记]]></title>
    <url>%2F2019%2F01%2F09%2Fnote%2F</url>
    <content type="text"><![CDATA[当使用makemigrations时报错No changes detected：(转https://blog.csdn.net/qq_39291784/article/details/78397589) 在修改了models.py后，有些用户会喜欢用python manage.py makemigrations生成对应的py代码。 但有时执行python manage.py makemigrations命令（也可能人比较皮，把migrations文件夹给删了），会提示”No changes detected.” 可能有用的解决方式如下： 先 python manage.py makemigrations –empty yourappname 生成一个空的initial.py 再 python manage.py makemigrations 生成原先的model对应的migration file 记录下git的一些操作指令，有时候忘了老要查(转https://www.jianshu.com/p/3be4029ce854) 123456789101112131415161718192021git branch -r #查看远程所有分支git branch #查看本地所有分支git branch -a #查看本地及远程的所有分支，如下图git fetch #将某个远程主机的更新，全部取回本地：git branch -a #查看远程分支git branch #查看本地分支：git checkout 分支 #切换分支：git push origin -d 分支名 #删除远程分支: git branch -d 分支名 #删除本地分支git remote show origin #查看远程分支和本地分支的对应关系git remote prune origin #删除远程已经删除过的分支 情景1：同步别人新增到远程的分支12341.git branch查看一下本地分支，再git branch -a查看一下远程分支，对比下，远程存在哪些本地没有的新分支. 2.将某个远程主机的更新，全部取回本地：git fetch 3.再次查看远程分支：git branch -a 发现远程的分支已经可以看见了 4.拉取远程分支到本地：git checkout -b 远程分支名 情景2：本地删除了分支，远程也想删除2.1:本地想要删除某个分支，远程仓库的这个分支也要删掉怎么办？12345a.使用git branch -d 分支名来删除本地分支。 b.使用git push origin -d 分支名直接来删除远程分支。在次使用git branch -a,发现分支已经不存在了。or a.使用git branch -d 分支名来删除本地分支。 b.最简单的解决办法就是直接到gitlab/github进行删除. 2.2:只把远程的删除掉怎么办？123a.使用git push origin -d 分支名直接来删除远程分支。此时删除的只是远程的分支，本地仍然存在ora.直接到gitlab/github进行删除. 2.3:远程删除了分支，本地也想删除eg:直接到gitlab/github删除了某个分支，我在本地使用git branch -a查看远程分支，依然存在并且可以切换使用。我本地也想把远程分支记录删除怎么办？123456789101112131415161718191.git branch -a查看远程分支，红色的是本地远程远程分支记录。2.执行下面命令查看远程仓库分支和本地仓库的远程分支记录的对应关系： git remote show origin 3.会看到： refs/remotes/origin/远程仓库已经删除的分支名 stale (use &apos;git remote prune&apos; to remove) 其中： Local refs configured for &apos;git push&apos;: 命令下面的分支是本地仓库的远程分支记录中仍存在的分支，但远程仓库已经不存在。4.输入git remote prune origin来删除远程仓库已经删除过的分支5.验证 git branch -a 此时可以看到本地远程分支记录已经和远程仓库保持一致了。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深刻理解Python中的元类(metaclass)（转）]]></title>
    <url>%2F2019%2F01%2F01%2Fmetaclass%2F</url>
    <content type="text"><![CDATA[原文转载地址（http://blog.jobbole.com/21351/） 译注：这是一篇在Stack overflow上很热的帖子。提问者自称已经掌握了有关Python OOP编程中的各种概念，但始终觉得元类(metaclass)难以理解。他知道这肯定和自省有关，但仍然觉得不太明白，希望大家可以给出一些实际的例子和代码片段以帮助理解，以及在什么情况下需要进行元编程。于是e-satis同学给出了神一般的回复，该回复获得了985点的赞同点数，更有人评论说这段回复应该加入到Python的官方文档中去。而e-satis同学本人在Stack Overflow中的声望积分也高达64271分。以下就是这篇精彩的回复（提示：非常长） 类也是对象 在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立： 1234567class ObjectCreator(object): passmy_object = ObjectCreator()print my_object&lt;__main__.ObjectCreator object at 0x8974f2c&gt; 但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段： 12class ObjectCreator(object): pass 将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作： 1) 你可以将它赋值给一个变量 2) 你可以拷贝它 3) 你可以为它增加属性 4) 你可以将它作为函数参数进行传递 下面是示例： 123456789101112131415161718192021print ObjectCreator # 你可以打印一个类，因为它其实也是一个对象&lt;class '__main__.ObjectCreator'&gt;def echo(o): print oecho(ObjectCreator) # 你可以将类做为参数传给函数&lt;class '__main__.ObjectCreator'&gt;print hasattr(ObjectCreator, 'new_attribute')FasleObjectCreator.new_attribute = 'foo' # 你可以为类增加属性print hasattr(ObjectCreator, 'new_attribute')Trueprint ObjectCreator.new_attributefooObjectCreatorMirror = ObjectCreator # 你可以将类赋值给一个变量print ObjectCreatorMirror()&lt;__main__.ObjectCreator object at 0x8997b4c&gt; 动态地创建类 因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。 1234567891011121314151617def choose_class(name): if name == 'foo': class Foo(object): pass return Foo # 返回的是类，不是类的实例 else: class Bar(object): pass return BarMyClass = choose_class('foo')print MyClass # 函数返回的是类，不是类的实例&lt;class '__main__'.Foo&gt;print MyClass() # 你可以通过这个类创建类实例，也就是对象&lt;__main__.Foo object at 0x89c6d4c&gt; 但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样： 12345678print type(1)&lt;type 'int'&gt;print type("1")&lt;type 'str'&gt;print type(ObjectCreator)&lt;type 'type'&gt;print type(ObjectCreator())&lt;class '__main__.ObjectCreator'&gt; 这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性） type可以像这样工作： type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）) type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）) 比如下面的代码： 1234567891011class MyShinyClass(object): pass#可以手动像这样创建：MyShinyClass = type('MyShinyClass', (), &#123;&#125;) # 返回一个类对象print MyShinyClass&lt;class '__main__.MyShinyClass'&gt;print MyShinyClass() # 创建一个该类的实例&lt;__main__.MyShinyClass object at 0x8997cec&gt; 你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。 type 接受一个字典来为类定义属性，因此 12class Foo(object): bar = True 可以翻译为： 12345678910111213141516Foo = type('Foo', (), &#123;'bar':True&#125;)#并且可以将Foo当成一个普通的类一样使用：print Foo&lt;class '__main__.Foo'&gt;print Foo.barTruef = Foo()print f&lt;__main__.Foo object at 0x8a9b84c&gt;print f.barTrue 当然，你可以向这个类继承，所以，如下的代码： 12class FooChild(Foo): pass 就可以写成： 1234567FooChild = type('FooChild', (Foo,),&#123;&#125;)print FooChild&lt;class '__main__.FooChild'&gt;print FooChild.bar # bar属性是由Foo继承而来True 最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。 12345678910111213def echo_bar(self): print self.barFooChild = type('FooChild', (Foo,), &#123;'echo_bar': echo_bar&#125;)hasattr(Foo, 'echo_bar')Falsehasattr(FooChild, 'echo_bar')Truemy_foo = FooChild()my_foo.echo_bar()True 你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。 到底什么是元类（终于到主题了） 元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为： 123456MyClass = MetaClass()MyObject = MyClass()#你已经看到了type可以让你像这样做：MyClass = type('MyClass', (), &#123;&#125;) 这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查class属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。 12345678910111213141516age = 35age.__class__&lt;type 'int'&gt;name = 'bob'name.__class__&lt;type 'str'&gt;def foo(): passfoo.__class__&lt;type 'function'&gt;class Bar(object): passb = Bar()b.__class__&lt;class '__main__.Bar'&gt; 现在，对于任何一个class的class属性又是什么呢？ 12345678910111213a.__class__.__class__&lt;type 'type'&gt;age.__class__.__class__&lt;type 'type'&gt;foo.__class__.__class__&lt;type 'type'&gt;b.__class__.__class__&lt;type 'type'&gt; 因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。 metaclass属性 你可以在写一个类的时候为其添加metaclass属性。 12345class Foo(object): __metaclass__ = something…class Foo(object): __metaclass__ = something… 如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找metaclass属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 : 12345class Foo(Bar): passclass Foo(Bar): pass Python做了如下的操作： Foo中有metaclass这个属性吗？如果是，Python会在内存中通过metaclass创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到metaclass，它会继续在Bar（父类）中寻找metaclass属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到metaclass，它就会在模块层次中去寻找metaclass，并尝试做同样的操作。如果还是找不到metaclass,Python就会用内置的type来创建这个类对象。 现在的问题就是，你可以在metaclass中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。 自定义元类 元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定metaclass。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。 幸运的是，metaclass实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。 1234567891011121314151617181920212223242526272829# 元类会自动将你通常传给‘type’的参数作为自己的参数传入def upper_attr(future_class_name, future_class_parents, future_class_attr): '''返回一个类对象，将属性都转为大写形式''' # 选择所有不以'__'开头的属性 attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__')) # 将它们转为大写形式 uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 通过'type'来做类对象的创建 return type(future_class_name, future_class_parents, uppercase_attr)__metaclass__ = upper_attr # 这会作用到这个模块中的所有类class Foo(object): # 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中 bar = 'bip'print hasattr(Foo, 'bar')# 输出: Falseprint hasattr(Foo, 'BAR')# 输出:Truef = Foo()print f.BAR# 输出:'bip' 现在让我们再做一次，这一次用一个真正的class来当做元类。 1234567891011121314# 请记住，'type'实际上是一个类，就像'str'和'int'一样# 所以，你可以从type继承class UpperAttrMetaClass(type): # __new__ 是在__init__之前被调用的特殊方法 # __new__是用来创建对象并返回之的方法 # 而__init__只是用来将传入的参数初始化给对象 # 你很少用到__new__，除非你希望能够控制对象的创建 # 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__ # 如果你希望的话，你也可以在__init__中做些事情 # 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用 def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__')) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return type(future_class_name, future_class_parents, uppercase_attr) 但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的new方法。现在让我们这样去处理: 12345678class UpperAttrMetaclass(type): def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr): attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__')) uppercase_attr = dict((name.upper(), value) for name, value in attrs) # 复用type.__new__方法 # 这就是基本的OOP编程，没什么魔法 return type.__new__(upperattr_metaclass, future_class_name, future_class_parents, uppercase_attr) 你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的： 12345class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith('__') uppercase_attr = dict((name.upper(), value) for name, value in attrs) return type.__new__(cls, name, bases, uppercase_attr) 如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承） 12345class UpperAttrMetaclass(type): def __new__(cls, name, bases, dct): attrs = ((name, value) for name, value in dct.items() if not name.startswith('__')) uppercase_attr = dict((name.upper(), value) for name, value in attrs) return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr) 就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的： 1) 拦截类的创建 2) 修改类 3) 返回修改之后的类 为什么要用metaclass类而不是函数? 由于metaclass可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因： 1） 意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。 2） 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。 3） 你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。 4） 你可以使用new, init以及call这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在new里处理掉，有些人还是觉得用init更舒服些。 5） 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！ 究竟为什么要使用元类？ 现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它： “元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters 元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义： 123class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField() 但是如果你像这样做的话： 12guy = Person(name='bob', age='35')print guy.age 这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了metaclass， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。 结语 首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。 123class Foo(object): passid(Foo)142630324 Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类： 1） Monkey patching 2) class decorators 当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python内置函数zip]]></title>
    <url>%2F2018%2F12%2F11%2FzipPython%2F</url>
    <content type="text"><![CDATA[python内置函数里有一个zip方法。第一次看起来有点不懂，于是查了下资料，找到一篇不错的文章，便想记录分享一下。原文出处链接点这里。此外我再补充个栈溢出上的问题讨论地址。 zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表。具体意思不好用文字来表述，直接看示例： 123456789x = [1, 2, 3]y = [4, 5, 6]z = [7, 8, 9]xyz = zip(x, y, z)print xyz 运行的结果是： [(1, 4, 7), (2, 5, 8), (3, 6, 9)] 从这个结果可以看出zip函数的基本运作方式。 2.示例2： 1234x = [1, 2, 3]y = [4, 5, 6, 7]xy = zip(x, y)print xy 运行的结果是： [(1, 4), (2, 5), (3, 6)] 从这个结果可以看出zip函数的长度处理方式。 3.示例3： 123x = [1, 2, 3]x = zip(x)print x 运行的结果是： [(1,), (2,), (3,)] 从这个结果可以看出zip函数在只有一个参数时运作的方式。 4.示例4： python12x = zip()print x 运行的结果是： [] 从这个结果可以看出zip函数在没有参数时运作的方式。 5.示例5： 1234567891011x = [1, 2, 3]y = [4, 5, 6]z = [7, 8, 9]xyz = zip(x, y, z)u = zip(*xyz)print u 运行的结果是： [(1, 2, 3), (4, 5, 6), (7, 8, 9)] 一般认为这是一个unzip的过程，它的运行机制是这样的： 在运行zip(*xyz)之前，xyz的值是：[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 那么，zip(*xyz) 等价于 zip((1, 4, 7), (2, 5, 8), (3, 6, 9)) 所以，运行结果是：[(1, 2, 3), (4, 5, 6), (7, 8, 9)] 注：在函数调用中使用*list/tuple的方式表示将list/tuple分开，作为位置参数传递给对应函数（前提是对应函数支持不定个数的位置参数）6.示例6：123x = [1, 2, 3]r = zip(* [x] * 3)print r 运行的结果是： [(1, 1, 1), (2, 2, 2), (3, 3, 3)] 它的运行机制是这样的： [x]生成一个列表的列表，它只有一个元素x [x] * 3生成一个列表的列表，它有3个元素，[x, x, x] zip( [x] 3)的意思就明确了，zip(x, x, x)]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web版极简马里奥游戏]]></title>
    <url>%2F2018%2F12%2F04%2Fmario%2F</url>
    <content type="text"><![CDATA[几个星期前，在B站上看人写游戏，开启了我一些思路，于是想自己也写个mario的小游戏吧。小时候自己很喜欢玩这款游戏，写出来也算是追忆下自己的童年了。说搞就搞，只写了些基本的场景，感觉回头我还需要把整个场景抽象出来，可回头又是什么时候呢？我也不知道。在线游戏地址，另外附上代码仓库地址]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raneto配置中文搜索]]></title>
    <url>%2F2018%2F09%2F20%2FranetoLurn%2F</url>
    <content type="text"><![CDATA[因工作需要，准备给公司搞个软件说明文档。但是这种东西我们又不想自己搭，于是就想找个开源的文档库。找啊找，于是就找到Raneto这么个东西。感觉还还不错，就决定用了。 官方文档还是相当清晰的。直接去github克隆，再直接npm start一下，就跑起来了。 然后我就把exampale文夹给换掉了。package.json文件夹的启动目录也换掉了。一切貌似都很顺利啊，但最后我居然发现不支持中文搜索。心里一惊，这还怎么玩！ 我就不信了，Google搜起来。于是我就看到了这篇文章Raneto部署。在文章的最后，作者给出了如下写道： 解决不能搜索中文的BUG 先下载一个lunr.js，链接：https://github.com/codepiano/lunr.js，解压并将文件夹命名为lunr，接下来进入node_modules目录，找到里面的lunr重命名为lunr2（不建议删除），然后再将刚下载的lunr复制进去。还要改一个地方，进入node_modules/raneto-core/node_modules目录，刚上面那个是一样的，将这里的lunr重命名为lunr2，再将刚下载的lunr复制进去。再次重启，这里重启的时候可能会出现error，原因是node.js少了一些库，仔细看缺了哪些库，然后npm install 然后我很兴奋啊，跟着步骤来啊。但是，我居然发现我找不到node_modules/raneto-core这个文件夹！ 后来我在github才发现gilbitron/Raneto-Core这个库已经被直接合并到gilbitron/Raneto Raneto Core LOCKEDThis codebase has been merged into the main Raneto projectNo new issues or PRs will be acceptedPlease visit the main Raneto repository 后来我就直接去Raneto的仓库上搜issues了。看到这一条Can’t search in Chinese. #41。其中有人提到codepiano/lunr.js很有用。 但是它的readme也没具体讲我怎么植入Raneto啊。 于是我又去lunr官网，想看看到底是个什么东西。文档说的很简单。我当时就把其思路简单理了下。我觉得大概思路就是，把要搜索的内容以一个数据结构来表示，然后把他们一个个放进个队列里，搜索的时候就直接遍历这个数组就好了。 比如，每篇文章都大概能分成三部分，标题，时间跟内容。我以这样的结构来表示{title:&#39;标题&#39;, dateTime:&#39;2018-01-01&#39;,conent:&#39;文章内容&#39;}.每篇文章都是这么个结构，把它们全部放到一个数组里面，搜索就是遍历这个数组里的每一项。但是既然要搜，我肯定要指定匹配数组里的每个对象的哪些个字段。于是lunr里文档里，有这么个说明。 1234567891011var idx = lunr(function () &#123; this.field('title') this.field('body') this.add(&#123; "title": "Twelfth-Night", "body": "If music be the food of love, play on: Give me excess of it…", "author": "William Shakespeare", "id": "1" &#125;)&#125;) 这里的 this.field(&#39;title&#39;); this.field(&#39;body&#39;) 就是指定要搜索匹配内容的字段名。上述意思就是，指定匹配标题跟内容字段，但是不匹配时间跟作者名。 我觉得大概就这么个意思，具体就没深究了。 说了上面一大堆，支持中文的lunr的库也找到，那怎么改Raneto呢？ 首先，我先找到了Raneto文件里的app/core/search.js文件。看到这行方法： 1234567891011function getLunr (config) &#123; if (instance === null) &#123; instance = require('lunr'); require('lunr-languages/lunr.stemmer.support')(instance); require('lunr-languages/lunr.multi')(instance); config.searchExtraLanguages.forEach(lang =&gt; require('lunr-languages/lunr.' + lang)(instance) ); &#125; return instance;&#125; 而这个方法又在search.js暴露出去的handler方法里调用。 1234567891011121314151617181920212223242526272829function handler (query, config) &#123; const contentDir = utils.normalizeDir(path.normalize(config.content_dir)); const documents = glob .sync(contentDir + '**/*.md') .map(filePath =&gt; contentProcessors.extractDocument( contentDir, filePath, config.debug )) .filter(doc =&gt; doc !== null); const lunrInstance = getLunr(config); const idx = lunrInstance(function () &#123; this.use(getStemmers(config)); this.field('title'); this.field('body'); this.ref('id'); documents.forEach((doc) =&gt; this.add(doc), this); &#125;); const results = idx.search(query); const searchResults = []; results.forEach(result =&gt; &#123; const p = pageHandler(contentDir + result.ref, config); p.excerpt = p.excerpt.replace(new RegExp('(' + query + ')', 'gim'), '&lt;span class="search-query"&gt;$1&lt;/span&gt;'); searchResults.push(p); &#125;); return searchResults;&#125; 显然getLunr这个方法是根据config.default.js的searchExtraLanguages: [&#39;ru&#39;]配置，加载支持特定语言搜索的lunr文件的。但是lunr-languages\里面没有一个支持中文的。于是我干脆就都给注释掉了，并把我下载好的codepiano/lunr.js文件，复制到了其同级目录，并引入。 1234567891011function getLunr (config) &#123; if (instance === null) &#123; instance = require('./lunr.js');//该文件lunr支持中文搜索 // require('lunr-languages/lunr.stemmer.support')(instance); // require('lunr-languages/lunr.multi')(instance); // config.searchExtraLanguages.forEach(lang =&gt; // require('lunr-languages/lunr.' + lang)(instance) // ); &#125; return instance;&#125; 同时注释掉了，handler里的this.use(getStemmers(config))调用。因为我看getStemmers也是加载config.searchExtraLanguages里的语言配置。感觉没什么用。 123456789101112131415161718function handler (query, config) &#123; const contentDir = utils.normalizeDir(path.normalize(config.content_dir)); const documents = glob .sync(contentDir + '**/*.md') .map(filePath =&gt; contentProcessors.extractDocument( contentDir, filePath, config.debug )) .filter(doc =&gt; doc !== null); const lunrInstance = getLunr(config); const idx = lunrInstance(function () &#123; //注释掉默认设置加载的lunr配置。因为上面的 lunr 文件支持中文。如果又配置config里的东西，将又还原成默认的语言搜素配置。将使中文失效。 //this.use(getStemmers(config)); this.field('title'); this.field('body'); this.ref('id'); documents.forEach((doc) =&gt; this.add(doc), this);&#125;); 重启，直接报错！缺少nodejieba模块。那就装一下，npm install --save nodejieba。 最后再次重启，感觉成了！！！就这么个东西，也是折腾了我很多时间。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抄一首诗]]></title>
    <url>%2F2018%2F09%2F18%2FaPoem%2F</url>
    <content type="text"><![CDATA[只要再克制一下，我就会解脱这割裂我内心的阵阵绞痛；最后一次对你和爱情长叹过，我就要再回到忙碌的人生。我如今随遇而安，善于混日子，尽管这种种从未使我喜欢；纵然世上的乐趣都已飞逝，有什么悲哀能再使我心酸？给我拿酒来吧，给我摆上筵席，人本来不适于孤独的生存；我将做一个无心的浪荡子弟，随大家欢笑，不要和人共悲恸。在美好的日子里我不是如此，我原不会这样，如果不是你，逝去了，把我孤独地留下度日，你化为虚无——一切也逝去了意义。———— 拜伦《只要再克制一下》]]></content>
      <categories>
        <category>文学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[日历插件 - ZCalendar.js]]></title>
    <url>%2F2017%2F12%2F11%2Fzcalender%2F</url>
    <content type="text"><![CDATA[ZCalendar.js本想给公司写个专门的日历插件，结果写到中间，说不需要了，遂终！ 用法及其简单，当然目前只具备展示的功能，其他功能尚待完善 完善日期未知…… 我的设想是不依托于其他 jQ或 moment.js 等任何js库，力求精简 Demo1234567891011121314151617181920 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="./ZCalendar.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='calendar' &gt;&lt;/div&gt; &lt;script src='./ZCalendar.js'&gt;&lt;/script&gt; &lt;script&gt; var ZCalendar = new ZCalendar(&#123; container:'#calendar' &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 不传 y[Number]，m[Number] 的情况下默认为当前时间 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160 /************************************************************************************** config [object | &#123;container[String] , y[Number], m[Number]&#125;];**********************************************************************************/function ZCalendar(config) &#123; this.presentTime = new Date(); this.container = config.container; this.currentMoment = new Date(config.y?config.y: this.presentTime.getFullYear() , config.m?config.m-1 : this.presentTime.getMonth() ); this.year = this.currentMoment.getFullYear(); this.month = this.currentMoment.getMonth() + 1; this.date = new Date().getDate(); this.init();&#125;ZCalendar.prototype = &#123; init: function () &#123; this.startDay = this.getStartDay();//该月1号为星期几； this.endDay = this.getEnDay();//该月最后一天为星期几； this.startDate = 1,//该月从 1 号开始； this.endDate = this.getEndDate();//该月 最后一天为几号 this.totalDays = this.endDate;//总天数 this.renderCalendar(); document.getElementById('zc-prev').onclick = this.prevClick.bind(this); document.getElementById('zc-next').onclick = this.nextClick.bind(this); &#125;, getStartDay: function () &#123;//获取 该月 1 号为星期几； return this.currentMoment.getDay(); &#125;, getEndDate: function () &#123;// 获取 该月 最后 一日 为 几号； return new Date(this.year, this.month, 0).getDate(); &#125;, getEnDay: function () &#123;// 获取 该月 最后 一日 为 星期几; return new Date(this.year, this.month - 1, this.getEndDate()).getDay(); &#125;, daysAlias: [ //中文星期几的别名 '周日', '周一', '周二', '周三', '周四', '周五', '周六' ], getChineseAliasDays: function (day) &#123;//获取中文对应的星期几别名； return daysAlias[day]; &#125;, renderDateTd: function (date) &#123;//渲染每个日期单元； return '&lt;td class="currentTime' + ((date == this.date) &amp;&amp; (this.year == this.presentTime.getFullYear() &amp;&amp; (this.month == this.presentTime.getMonth()+1) ) ? ' active' : '') + '" &gt;' + date + '&lt;/td&gt;'; &#125;, renderStartEmptyTd: function () &#123;//渲染 每月开始之前的 多余的 周几 的空格 占位符； return '&lt;td&gt;&lt;/td&gt;'; &#125;, renderEndEmptyTd: function () &#123; &#125;, renderCalendarBody: function () &#123; var calendarTds = ''; for (var j = 0; j &lt; 6; j++) &#123; calendarTds += '&lt;tr&gt;'; for (var i = 0; i &lt; 7; i++) &#123; var index = j * 7 + i; if (index &lt; this.startDay || index &gt;= (this.endDate + this.startDay)) &#123; calendarTds += this.renderStartEmptyTd(); &#125; if (index &gt;= this.startDay &amp;&amp; index &lt; (this.endDate + this.startDay)) &#123; calendarTds += this.renderDateTd(index - this.startDay + 1); &#125; &#125; calendarTds += '&lt;/tr&gt;' &#125; return '&lt;tbody&gt;' + calendarTds + '&lt;/tbody&gt;'; &#125;, renderCalendarHead: function () &#123; var head = '&lt;thead&gt;&lt;tr&gt;' for (var i = 0; i &lt; this.daysAlias.length; i++) &#123; head += this.renderDateTd(this.daysAlias[i]); &#125; head += '&lt;/tr&gt;&lt;/thead&gt;' return head; &#125;, renderTimeShowBox: function () &#123; var timeBox = '&lt;div class="zc-timebox"&gt;' + '&lt;div class="zc-time"&gt;' + '&lt;span id="zc-prev"&gt; &lt; &lt;/span&gt;' + '&lt;span class="zc-time-item"&gt;' + this.year + '&lt;/span&gt;年' + '&lt;span class="zc-time-item"&gt;' + this.month + '&lt;/span&gt;月' + '&lt;span id="zc-next"&gt; &gt; &lt;/span&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'; return timeBox; &#125;, renderCalendarTable: function () &#123; var tableHead = this.renderCalendarHead(); var tableBody = this.renderCalendarBody(); var calendarTabel = '&lt;table class="zc-table" width="100%" border=0 cellspacing=0 &gt;' + tableHead + tableBody + '&lt;/table&gt;'; return calendarTabel; &#125;, renderCalendar: function () &#123; var calender = ''; calender += this.renderTimeShowBox() + this.renderCalendarTable(); calender = '&lt;div&gt;' + calender + '&lt;/div&gt;'; document.querySelector(this.container).innerHTML = calender; &#125;, prevClick: function () &#123; this.currentMoment = new Date(this.year, this.month - 2); this.year = this.currentMoment.getFullYear(); this.month = this.currentMoment.getMonth() + 1; this.date = new Date().getDate(); this.init(); &#125;, nextClick: function () &#123; this.currentMoment = new Date(this.year, this.month); this.year = this.currentMoment.getFullYear(); this.month = this.currentMoment.getMonth() + 1; this.date = new Date().getDate(); this.init(); &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
