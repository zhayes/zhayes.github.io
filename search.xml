<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web版极简马里奥游戏]]></title>
    <url>%2F2018%2F12%2F11%2FzipPython%2F</url>
    <content type="text"><![CDATA[python内置函数里有一个zip方法。第一次看起来有点不懂，于是查了下资料，看到个不错的文章，于是想记录分享一下。原文出处链接点这里。 zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表。具体意思不好用文字来表述，直接看示例： 123456789x = [1, 2, 3]y = [4, 5, 6]z = [7, 8, 9]xyz = zip(x, y, z)print xyz 运行的结果是： [(1, 4, 7), (2, 5, 8), (3, 6, 9)] 从这个结果可以看出zip函数的基本运作方式。 2.示例2： 1234x = [1, 2, 3]y = [4, 5, 6, 7]xy = zip(x, y)print xy 运行的结果是： [(1, 4), (2, 5), (3, 6)] 从这个结果可以看出zip函数的长度处理方式。 3.示例3： 123x = [1, 2, 3]x = zip(x)print x 运行的结果是： [(1,), (2,), (3,)] 从这个结果可以看出zip函数在只有一个参数时运作的方式。 4.示例4： python12x = zip()print x 运行的结果是： [] 从这个结果可以看出zip函数在没有参数时运作的方式。 5.示例5： 1234567891011x = [1, 2, 3]y = [4, 5, 6]z = [7, 8, 9]xyz = zip(x, y, z)u = zip(*xyz)print u 运行的结果是： [(1, 2, 3), (4, 5, 6), (7, 8, 9)] 一般认为这是一个unzip的过程，它的运行机制是这样的： 在运行zip(*xyz)之前，xyz的值是：[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 那么，zip(*xyz) 等价于 zip((1, 4, 7), (2, 5, 8), (3, 6, 9)) 所以，运行结果是：[(1, 2, 3), (4, 5, 6), (7, 8, 9)] 注：在函数调用中使用*list/tuple的方式表示将list/tuple分开，作为位置参数传递给对应函数（前提是对应函数支持不定个数的位置参数） 6.示例6：123x = [1, 2, 3]r = zip(* [x] * 3)print r 运行的结果是： [(1, 1, 1), (2, 2, 2), (3, 3, 3)] 它的运行机制是这样的： [x]生成一个列表的列表，它只有一个元素x [x] * 3生成一个列表的列表，它有3个元素，[x, x, x] zip( [x] 3)的意思就明确了，zip(x, x, x)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web版极简马里奥游戏]]></title>
    <url>%2F2018%2F12%2F04%2Fmario%2F</url>
    <content type="text"><![CDATA[几个星期前，在B站上看人写游戏，开启了我一些思路，于是想自己也写个mario的小游戏吧。小时候自己很喜欢玩这款游戏，写出来也算是追忆下自己的童年了。说搞就搞，只写了些基本的场景，感觉回头我还需要把整个场景抽象出来，可回头又是什么时候呢？我也不知道。在线游戏地址，另外附上代码仓库地址]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raneto配置中文搜索]]></title>
    <url>%2F2018%2F09%2F20%2FranetoLurn%2F</url>
    <content type="text"><![CDATA[因工作需要，准备给公司搞个软件说明文档。但是这种东西我们又不想自己搭，于是就想找个开源的文档库。找啊找，于是就找到Raneto这么个东西。感觉还还不错，就决定用了。 官方文档还是相当清晰的。直接去github克隆，再直接npm start一下，就跑起来了。 然后我就把exampale文夹给换掉了。package.json文件夹的启动目录也换掉了。一切貌似都很顺利啊，但最后我居然发现不支持中文搜索。心里一惊，这还怎么玩！ 我就不信了，Google搜起来。于是我就看到了这篇文章Raneto部署。在文章的最后，作者给出了如下写道： 解决不能搜索中文的BUG 先下载一个lunr.js，链接：https://github.com/codepiano/lunr.js，解压并将文件夹命名为lunr，接下来进入node_modules目录，找到里面的lunr重命名为lunr2（不建议删除），然后再将刚下载的lunr复制进去。还要改一个地方，进入node_modules/raneto-core/node_modules目录，刚上面那个是一样的，将这里的lunr重命名为lunr2，再将刚下载的lunr复制进去。再次重启，这里重启的时候可能会出现error，原因是node.js少了一些库，仔细看缺了哪些库，然后npm install 然后我很兴奋啊，跟着步骤来啊。但是，我居然发现我找不到node_modules/raneto-core这个文件夹！ 后来我在github才发现gilbitron/Raneto-Core这个库已经被直接合并到gilbitron/Raneto Raneto Core LOCKEDThis codebase has been merged into the main Raneto projectNo new issues or PRs will be acceptedPlease visit the main Raneto repository 后来我就直接去Raneto的仓库上搜issues了。看到这一条Can’t search in Chinese. #41。其中有人提到codepiano/lunr.js很有用。 但是它的readme也没具体讲我怎么植入Raneto啊。 于是我又去lunr官网，想看看到底是个什么东西。文档说的很简单。我当时就把其思路简单理了下。我觉得大概思路就是，把要搜索的内容以一个数据结构来表示，然后把他们一个个放进个队列里，搜索的时候就直接遍历这个数组就好了。 比如，每篇文章都大概能分成三部分，标题，时间跟内容。我以这样的结构来表示{title:&#39;标题&#39;, dateTime:&#39;2018-01-01&#39;,conent:&#39;文章内容&#39;}.每篇文章都是这么个结构，把它们全部放到一个数组里面，搜索就是遍历这个数组里的每一项。但是既然要搜，我肯定要指定匹配数组里的每个对象的哪些个字段。于是lunr里文档里，有这么个说明。 1234567891011var idx = lunr(function () &#123; this.field('title') this.field('body') this.add(&#123; "title": "Twelfth-Night", "body": "If music be the food of love, play on: Give me excess of it…", "author": "William Shakespeare", "id": "1" &#125;)&#125;) 这里的 this.field(&#39;title&#39;); this.field(&#39;body&#39;) 就是指定要搜索匹配内容的字段名。上述意思就是，指定匹配标题跟内容字段，但是不匹配时间跟作者名。 我觉得大概就这么个意思，具体就没深究了。 说了上面一大堆，支持中文的lunr的库也找到，那怎么改Raneto呢？ 首先，我先找到了Raneto文件里的app/core/search.js文件。看到这行方法： 1234567891011function getLunr (config) &#123; if (instance === null) &#123; instance = require('lunr'); require('lunr-languages/lunr.stemmer.support')(instance); require('lunr-languages/lunr.multi')(instance); config.searchExtraLanguages.forEach(lang =&gt; require('lunr-languages/lunr.' + lang)(instance) ); &#125; return instance;&#125; 而这个方法又在search.js暴露出去的handler方法里调用。 1234567891011121314151617181920212223242526272829function handler (query, config) &#123; const contentDir = utils.normalizeDir(path.normalize(config.content_dir)); const documents = glob .sync(contentDir + '**/*.md') .map(filePath =&gt; contentProcessors.extractDocument( contentDir, filePath, config.debug )) .filter(doc =&gt; doc !== null); const lunrInstance = getLunr(config); const idx = lunrInstance(function () &#123; this.use(getStemmers(config)); this.field('title'); this.field('body'); this.ref('id'); documents.forEach((doc) =&gt; this.add(doc), this); &#125;); const results = idx.search(query); const searchResults = []; results.forEach(result =&gt; &#123; const p = pageHandler(contentDir + result.ref, config); p.excerpt = p.excerpt.replace(new RegExp('(' + query + ')', 'gim'), '&lt;span class="search-query"&gt;$1&lt;/span&gt;'); searchResults.push(p); &#125;); return searchResults;&#125; 显然getLunr这个方法是根据config.default.js的searchExtraLanguages: [&#39;ru&#39;]配置，加载支持特定语言搜索的lunr文件的。但是lunr-languages\里面没有一个支持中文的。于是我干脆就都给注释掉了，并把我下载好的codepiano/lunr.js文件，复制到了其同级目录，并引入。 1234567891011function getLunr (config) &#123; if (instance === null) &#123; instance = require('./lunr.js');//该文件lunr支持中文搜索 // require('lunr-languages/lunr.stemmer.support')(instance); // require('lunr-languages/lunr.multi')(instance); // config.searchExtraLanguages.forEach(lang =&gt; // require('lunr-languages/lunr.' + lang)(instance) // ); &#125; return instance;&#125; 同时注释掉了，handler里的this.use(getStemmers(config))调用。因为我看getStemmers也是加载config.searchExtraLanguages里的语言配置。感觉没什么用。 123456789101112131415161718function handler (query, config) &#123; const contentDir = utils.normalizeDir(path.normalize(config.content_dir)); const documents = glob .sync(contentDir + '**/*.md') .map(filePath =&gt; contentProcessors.extractDocument( contentDir, filePath, config.debug )) .filter(doc =&gt; doc !== null); const lunrInstance = getLunr(config); const idx = lunrInstance(function () &#123; //注释掉默认设置加载的lunr配置。因为上面的 lunr 文件支持中文。如果又配置config里的东西，将又还原成默认的语言搜素配置。将使中文失效。 //this.use(getStemmers(config)); this.field('title'); this.field('body'); this.ref('id'); documents.forEach((doc) =&gt; this.add(doc), this);&#125;); 重启，直接报错！缺少nodejieba模块。那就装一下，npm install --save nodejieba。 最后再次重启，感觉成了！！！就这么个东西，也是折腾了我很多时间。]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抄一首诗]]></title>
    <url>%2F2018%2F09%2F18%2FaPoem%2F</url>
    <content type="text"><![CDATA[只要再克制一下，我就会解脱这割裂我内心的阵阵绞痛；最后一次对你和爱情长叹过，我就要再回到忙碌的人生。我如今随遇而安，善于混日子，尽管这种种从未使我喜欢；纵然世上的乐趣都已飞逝，有什么悲哀能再使我心酸？给我拿酒来吧，给我摆上筵席，人本来不适于孤独的生存；我将做一个无心的浪荡子弟，随大家欢笑，不要和人共悲恸。在美好的日子里我不是如此，我原不会这样，如果不是你，逝去了，把我孤独地留下度日，你化为虚无——一切也逝去了意义。———— 拜伦《只要再克制一下》]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
</search>
